// ==========================
// ==== Helper Functions ====
// ==========================


// @function Rescales a source value with an unbounded range to a target range.
// @param src <series float> The input series
// @param min <float> The minimum value of the unbounded range
// @param max <float> The maximum value of the unbounded range
// @returns <series float> The normalized series
export normalize(series float src, float min, float max) =>
    var _historicMin =  10e10
    var _historicMax = -10e10
    _historicMin := math.min(nz(src, _historicMin), _historicMin)
    _historicMax := math.max(nz(src, _historicMax), _historicMax)
    min + (max - min) * (src - _historicMin) / math.max(_historicMax - _historicMin, 10e-10)

// @function Rescales a source value with a bounded range to anther bounded range
// @param src <series float> The input series
// @param oldMin <float> The minimum value of the range to rescale from
// @param oldMax <float> The maximum value of the range to rescale from
// @param newMin <float> The minimum value of the range to rescale to
// @param newMax <float> The maximum value of the range to rescale to
// @returns <series float> The rescaled series
export rescale(series float src, float oldMin, float oldMax, float newMin, float newMax) =>
    newMin + (newMax - newMin) * (src - oldMin) / math.max(oldMax - oldMin, 10e-10)


// @function Returns the normalized RSI ideal for use in ML algorithms.
// @param src <series float> The input series (i.e., the result of the RSI calculation).
// @param n1 <int> The length of the RSI.
// @param n2 <int> The smoothing length of the RSI.
// @returns signal <series float> The normalized RSI.
export n_rsi(series float src, simple int n1, simple int n2) =>
    rescale(ta.ema(ta.rsi(src, n1), n2), 0, 100, 0, 1)

// @function Returns the normalized CCI ideal for use in ML algorithms.
// @param src <series float> The input series (i.e., the result of the CCI calculation).
// @param n1 <int> The length of the CCI.
// @param n2 <int> The smoothing length of the CCI.
// @returns signal <series float> The normalized CCI.
export n_cci(series float src, simple int n1, simple int n2) =>
    normalize(ta.ema(ta.cci(src, n1), n2), 0, 1)

// @function Returns the normalized WaveTrend Classic series ideal for use in ML algorithms.
// @param src <series float> The input series (i.e., the result of the WaveTrend Classic calculation).
// @param paramA <int> The first smoothing length for WaveTrend Classic.
// @param paramB <int> The second smoothing length for the WaveTrend Classic.
// @param transformLength <int> The length of the transform.
// @returns signal <series float> The normalized WaveTrend Classic series.
export n_wt(series float src, simple int n1=10, simple int n2=11) =>
    ema1 = ta.ema(src, n1)
    ema2 = ta.ema(math.abs(src - ema1), n1)
    ci = (src - ema1) / (0.015 * ema2)
    wt1 = ta.ema(ci, n2) // tci
    wt2 = ta.sma(wt1, 4)
    normalize(wt1 - wt2, 0, 1)

// @function Returns the normalized ADX ideal for use in ML algorithms.
// @param highSrc <series float> The input series for the high price.
// @param lowSrc <series float> The input series for the low price.
// @param closeSrc <series float> The input series for the close price.
// @param n1 <int> The length of the ADX.
export n_adx(series float highSrc, series float lowSrc, series float closeSrc, simple int n1) =>
    length = n1
    th = 20
    tr = math.max(math.max(highSrc - lowSrc, math.abs(highSrc - nz(closeSrc[1]))), math.abs(lowSrc - nz(closeSrc[1])))
    directionalMovementPlus = highSrc - nz(highSrc[1]) > nz(lowSrc[1]) - lowSrc ? math.max(highSrc - nz(highSrc[1]), 0) : 0
    negMovement = nz(lowSrc[1]) - lowSrc > highSrc - nz(highSrc[1]) ? math.max(nz(lowSrc[1]) - lowSrc, 0) : 0
    trSmooth = 0.0
    trSmooth := nz(trSmooth[1]) - nz(trSmooth[1]) / length + tr
    smoothDirectionalMovementPlus = 0.0
    smoothDirectionalMovementPlus := nz(smoothDirectionalMovementPlus[1]) - nz(smoothDirectionalMovementPlus[1]) / length + directionalMovementPlus
    smoothnegMovement = 0.0
    smoothnegMovement := nz(smoothnegMovement[1]) - nz(smoothnegMovement[1]) / length + negMovement
    diPositive = smoothDirectionalMovementPlus / trSmooth * 100
    diNegative = smoothnegMovement / trSmooth * 100
    dx = math.abs(diPositive - diNegative) / (diPositive + diNegative) * 100
    adx = ta.rma(dx, length)
    rescale(adx, 0, 100, 0, 1)


// =================
// ==== Filters ====
// =================

// # @regime_filter
// # @param src <series float> The source series.
// # @param threshold <float> The threshold.
// # @param useRegimeFilter <bool> Whether to use the regime filter.
// # @returns <bool> Boolean indicating whether or not to let the signal pass through the filter.
export regime_filter(series float src=ohlc4, float threshold, bool useRegimeFilter) =>
    // Calculate the slope of the curve.
    value1 = 0.0
    value2 = 0.0
    klmf = 0.0
    value1 := 0.2 * (src - src[1]) + 0.8 * nz(value1[1])
    value2 := 0.1 * (high - low) + 0.8 * nz(value2[1])
    omega = math.abs(value1 / value2)
    alpha = (-math.pow(omega,2) + math.sqrt(math.pow(omega, 4) + 16 * math.pow(omega,2))) / 8
    klmf := alpha * src + (1 - alpha) * nz(klmf[1])
    absCurveSlope = math.abs(klmf - klmf[1])
    exponentialAverageAbsCurveSlope = 1.0 * ta.ema(absCurveSlope, 200)
    normalized_slope_decline = (absCurveSlope - exponentialAverageAbsCurveSlope) / exponentialAverageAbsCurveSlope
    // Calculate the slope of the curve.
    useRegimeFilter ? normalized_slope_decline >= threshold : true

// @function filter_adx
// @param src <series float> The source series.
// @param length <int> The length of the ADX.
// @param adxThreshold <int> The ADX threshold.
// @param useAdxFilter <bool> Whether to use the ADX filter.
// @returns <series float> The ADX.
export filter_adx(series float src=close, simple int length=14, int adxThreshold, bool useAdxFilter) =>
    tr = math.max(math.max(high - low, math.abs(high - nz(src[1]))), math.abs(low - nz(src[1])))
    directionalMovementPlus = high - nz(high[1]) > nz(low[1]) - low ? math.max(high - nz(high[1]), 0) : 0
    negMovement = nz(low[1]) - low > high - nz(high[1]) ? math.max(nz(low[1]) - low, 0) : 0
    trSmooth = 0.0
    trSmooth := nz(trSmooth[1]) - nz(trSmooth[1]) / length + tr
    smoothDirectionalMovementPlus = 0.0
    smoothDirectionalMovementPlus := nz(smoothDirectionalMovementPlus[1]) - nz(smoothDirectionalMovementPlus[1]) / length + directionalMovementPlus
    smoothnegMovement = 0.0
    smoothnegMovement := nz(smoothnegMovement[1]) - nz(smoothnegMovement[1]) / length + negMovement
    diPositive = smoothDirectionalMovementPlus / trSmooth * 100
    diNegative = smoothnegMovement / trSmooth * 100
    dx = math.abs(diPositive - diNegative) / (diPositive + diNegative) * 100
    adx = ta.rma(dx, length)
    useAdxFilter ? adx > adxThreshold : true

// @function filter_volatility
// @param minLength <int> The minimum length of the ATR.
// @param maxLength <int> The maximum length of the ATR.
// @param useVolatilityFilter <bool> Whether to use the volatility filter.
// @returns <bool> Boolean indicating whether or not to let the signal pass through the filter.
export filter_volatility(simple int minLength=1, simple int maxLength=10, bool useVolatilityFilter) =>
    recentAtr = ta.atr(minLength)
    historicalAtr = ta.atr(maxLength)
    useVolatilityFilter ? recentAtr > historicalAtr : true