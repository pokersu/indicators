precision=4
max_labels_count=500

// ====================
// ==== Background ====
// ====================

// 在使用类似K-最近邻算法的机器学习算法时，选择适当的距离度量是至关重要的。欧几里得距离通常被用作默认的距离度量，但它并不总是最佳选择。
// 这是因为市场数据通常会受到与重大世界事件的接近度的影响，如FOMC会议和黑天鹅事件。这些重大经济事件可以导致类似于大物体对时空的引力弯曲的弯曲效应。
// 在金融市场中，这种弯曲效应在一个连续的范围内运作，可以类比为“价格-时间”。

// 为了更好地考虑这种弯曲效应，可以使用Lorentzian距离作为欧几里得距离的替代距离度量。
// Lorentzian空间的几何形状一开始可能很难可视化，通过涉及2个特征维度（z=2）的示例是直观理解它的最佳方式。
// 为了这个示例的目的，让我们假设这两个特征是相对强度指数（RSI）和平均方向指数（ADX）。实际上，最佳特征数量在3-8的范围内，但为了简单起见，我们在这个示例中只使用2个特征。

// 基本假设：
// (1) 我们可以计算给定图表的RSI和ADX。
// (2) 为了简单起见，假设RSI和ADX的值遵循0到100的高斯分布。
// (3) 最近的RSI和ADX值可以被视为以ADX在x轴上和RSI在y轴上的坐标系的原点。

// 欧几里得空间中的距离：
// 用最近点作为原点来测量历史值的欧几里得距离将产生类似于下图1的分布。

//                        [RSI]
//                          |
//                          |
//                          |
//                      ...:::....
//                .:.:::••••••:::•::..
//              .:•:.:•••::::••::••....::.
//             ....:••••:••••••••::••:...:•.
//            ...:.::::::•••:::•••:•••::.:•..
//            ::•:.:•:•••••••:.:•::::::...:..
//  |--------.:•••..•••••••:••:...:::•:•:..:..----------[ADX]
//  0        :•:....:•••••::.:::•••::••:.....
//           ::....:.:••••••••:•••::••::..:.
//            .:...:••:::••••••••::•••....:
//              ::....:.....:•::•••:::::..
//                ..:..::••..::::..:•:..
//                    .::..:::.....:
//                          |
//                          |
//                          |
//                          |
//                         _|_ 0
//
//        Figure 1: 在欧几里得空间中的邻域

// 在Lorentzian空间中的距离：
// 然而，使用Lorentzian距离测量的相同一组历史值将产生一个不同的分布，类似于下图2（下图）。

//
//                         [RSI]
//  ::..                     |                    ..:::
//   .....                   |                  ......
//    .••••::.               |               :••••••.
//     .:•••••:.             |            :::••••••.
//       .•••••:...          |         .::.••••••.
//         .::•••••::..      |       :..••••••..
//            .:•••••••::.........::••••••:..
//              ..::::••••.•••••••.•••••••:.
//                ...:•••••••.•••••••••::.
//                  .:..••.••••••.••••..
//  |---------------.:•••••••••••••••••.---------------[ADX]
//  0             .:•:•••.••••••.•••••••.
//              .••••••••••••••••••••••••:.
//            .:••••••••••::..::.::••••••••:.
//          .::••••••::.     |       .::•••:::.
//         .:••••••..        |          :••••••••.
//       .:••••:...          |           ..•••••••:.
//     ..:••::..             |              :.•••••••.
//    .:•....                |               ...::.:••.
//   ...:..                  |                   :...:••.
//  :::.                     |                       ..::
//                          _|_ 0
//
//       Figure 2: 在Lorentzian空间中的邻域


// 观察结果：
// (1) 在Lorentzian空间中，两点之间的最短距离不一定是一条直线，而是一个测地线曲线。
// (2) Lorentzian距离的弯曲效应减少了异常值和噪音的整体影响。
// (3) 随着用于比较的最近邻居数量的增加，Lorentzian距离与欧几里得距离的差异逐渐增大。

// ======================
// ==== Custom Types ====
// ======================

// This section uses PineScript's new Type syntax to define important data structures
// used throughout the script.

type Settings
    float source
    int neighborsCount
    int maxBarsBack
    int featureCount
    int colorCompression
    bool showExits
    bool useDynamicExits

type Label
    int long
    int short
    int neutral

type FeatureArrays
    array<float> f1
    array<float> f2
    array<float> f3
    array<float> f4
    array<float> f5

type FeatureSeries
    float f1
    float f2
    float f3
    float f4
    float f5

type MLModel
    int firstBarIndex
    array<int> trainingLabels
    int loopSize
    float lastDistance
    array<float> distancesArray
    array<int> predictionsArray
    int prediction

type FilterSettings
    bool useVolatilityFilter
    bool useRegimeFilter
    bool useAdxFilter
    float regimeThreshold
    int adxThreshold

type Filter
    bool volatility
    bool regime
    bool adx

// ==========================
// ==== Helper Functions ====
// ==========================

series_from(feature_string, _close, _high, _low, _hlc3, f_paramA, f_paramB) =>
    switch feature_string
        "RSI" => ml.n_rsi(_close, f_paramA, f_paramB)
        "WT" => ml.n_wt(_hlc3, f_paramA, f_paramB)
        "CCI" => ml.n_cci(_close, f_paramA, f_paramB)
        "ADX" => ml.n_adx(_high, _low, _close, f_paramA)

get_lorentzian_distance(int i, int featureCount, FeatureSeries featureSeries, FeatureArrays featureArrays) =>
    switch featureCount
        5 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) +
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i))) +
             math.log(1+math.abs(featureSeries.f5 - array.get(featureArrays.f5, i)))
        4 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) +
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i)))
        3 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i)))
        2 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)))

// ================
// ==== Inputs ====
// ================

// Settings Object: General User-Defined Inputs
Settings settings =
 Settings.new(
   input.source(title='数据来源', defval=close, group="通用设置", tooltip="输入数据的来源"),
   input.int(title='最近邻居数量', defval=8, group="通用设置", minval=1, maxval=100, step=1, tooltip="要考虑的邻居数量"),
   input.int(title="最大回溯条数", defval=2000, group="通用设置"),
   input.int(title="特征数量", defval=5, group="Feature Engineering", minval=2, maxval=5, tooltip="用于机器学习预测的特征数量。"),
   input.int(title="颜色压缩", defval=1, group="通用设置", minval=1, maxval=10, tooltip="用于调整颜色比例强度的压缩因子。"),
   input.bool(title="显示默认退出点", defval=false, group="通用设置", tooltip="默认退出点在入场信号后正好4个周期出现。这对应于模型训练过程中的交易预定义长度。", inline="exits"),
   input.bool(title="使用动态退出点", defval=false, group="通用设置", tooltip="动态退出点尝试通过基于核回归逻辑动态调整退出阈值来让利润滑动。", inline="exits")
 )

// 交易统计设置
// 注意：交易统计部分不是用来替代适当的回测的。它仅用于校准目的。
showTradeStats = input.bool(true, '显示交易统计', tooltip='显示给定配置的交易统计数据。用于优化特征工程部分的设置非常有用。这不应该替代回测，仅应用于校准目的。早期信号翻转表示模型在4个周期内改变信号的情况；较高的值可能表明市场条件波动（横盘）较大。', group="通用设置")
useWorstCase = input.bool(false, "使用最坏情况估计", tooltip="是否使用回测的最坏情况估计。这个选项可以用于创建基于仅使用收盘价格的保守估计，从而避免了周期内的重新绘制效果。此选项假定用户不会在信号首次出现时入场，而是等待周期结束后进行确认。在较大的时间框架上，这可能意味着在大幅波动发生后才入场。通常情况下，禁用此选项对于将此指标作为交叉验证来源并更喜欢演示自由选择中期入场的估计的人更好。离开此选项禁用可能与传统的回测结果更一致。", group="通用设置")

// 用户定义设置的设置对象
FilterSettings filterSettings =
 FilterSettings.new(
   input.bool(title="使用波动过滤器", defval=true, tooltip="是否使用波动性过滤器", group="过滤器"),
   input.bool(title="使用制度过滤器", defval=true, group="过滤器", inline="regime"),
   input.bool(title="使用ADX过滤器", defval=false, group="过滤器", inline="adx"),
   input.float(title="阈值", defval=-0.1, minval=-10, maxval=10, step=0.1, tooltip="是否使用趋势检测过滤器。用于检测趋势/震荡市场的阈值", group="过滤器", inline="regime"),
   input.int(title="阈值", defval=20, minval=0, maxval=100, step=1, tooltip="是否使用ADX过滤器。用于检测趋势/震荡市场的阈值", group="过滤器", inline="adx")
 )

// 用于过滤机器学习预测的过滤器对象
Filter filter =
 Filter.new(
   ml.filter_volatility(1, 10, filterSettings.useVolatilityFilter),
   ml.regime_filter(ohlc4, filterSettings.regimeThreshold, filterSettings.useRegimeFilter),
   ml.filter_adx(settings.source, 14, filterSettings.adxThreshold, filterSettings.useAdxFilter)
  )

// 特征变量：用于计算特征序列的用户定义输入。
f1_string = input.string(title="Feature 1", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "01", tooltip="The first feature to use for ML predictions.", group="Feature Engineering")
f1_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 1.", defval=14, inline = "02", group="Feature Engineering")
f1_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 2 (if applicable).", defval=1, inline = "02", group="Feature Engineering")
f2_string = input.string(title="Feature 2", options=["RSI", "WT", "CCI", "ADX"], defval="WT", inline = "03", tooltip="The second feature to use for ML predictions.", group="Feature Engineering")
f2_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 2.", defval=10, inline = "04", group="Feature Engineering")
f2_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 2 (if applicable).", defval=11, inline = "04", group="Feature Engineering")
f3_string = input.string(title="Feature 3", options=["RSI", "WT", "CCI", "ADX"], defval="CCI", inline = "05", tooltip="The third feature to use for ML predictions.", group="Feature Engineering")
f3_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 3.", defval=20, inline = "06", group="Feature Engineering")
f3_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 3 (if applicable).", defval=1, inline = "06", group="Feature Engineering")
f4_string = input.string(title="Feature 4", options=["RSI", "WT", "CCI", "ADX"], defval="ADX", inline = "07", tooltip="The fourth feature to use for ML predictions.", group="Feature Engineering")
f4_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 4.", defval=20, inline = "08", group="Feature Engineering")
f4_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 4 (if applicable).", defval=2, inline = "08", group="Feature Engineering")
f5_string = input.string(title="Feature 5", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "09", tooltip="The fifth feature to use for ML predictions.", group="Feature Engineering")
f5_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 5.", defval=9, inline = "10", group="Feature Engineering")
f5_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 5 (if applicable).", defval=1, inline = "10", group="Feature Engineering")

// FeatureSeries Object: Calculated Feature Series based on Feature Variables
featureSeries =
 FeatureSeries.new(
   series_from(f1_string, close, high, low, hlc3, f1_paramA, f1_paramB), // f1
   series_from(f2_string, close, high, low, hlc3, f2_paramA, f2_paramB), // f2
   series_from(f3_string, close, high, low, hlc3, f3_paramA, f3_paramB), // f3
   series_from(f4_string, close, high, low, hlc3, f4_paramA, f4_paramB), // f4
   series_from(f5_string, close, high, low, hlc3, f5_paramA, f5_paramB)  // f5
 )

// FeatureArrays Variables: Storage of Feature Series as Feature Arrays Optimized for ML
// Note: These arrays cannot be dynamically created within the FeatureArrays Object Initialization and thus must be set-up in advance.
var f1Array = array.new_float()
var f2Array = array.new_float()
var f3Array = array.new_float()
var f4Array = array.new_float()
var f5Array = array.new_float()
array.push(f1Array, featureSeries.f1)
array.push(f2Array, featureSeries.f2)
array.push(f3Array, featureSeries.f3)
array.push(f4Array, featureSeries.f4)
array.push(f5Array, featureSeries.f5)

// FeatureArrays Object: Storage of the calculated FeatureArrays into a single object
featureArrays =
 FeatureArrays.new(
  f1Array, // f1
  f2Array, // f2
  f3Array, // f3
  f4Array, // f4
  f5Array  // f5
 )

// Label Object: Used for classifying historical data as training data for the ML Model
Label direction =
 Label.new(
   long=1,
   short=-1,
   neutral=0
  )

// 基于常规设置
maxBarsBackIndex = last_bar_index >= settings.maxBarsBack ? last_bar_index - settings.maxBarsBack : 0

// SMA 设置
useEmaFilter = input.bool(title="使用EMA过滤器", defval=false, group="过滤器", inline="ema")
emaPeriod = input.int(title="周期", defval=200, minval=1, step=1, group="过滤器", inline="ema", tooltip="用于EMA过滤器的EMA的周期.")
isEmaUptrend = useEmaFilter ? close > ta.ema(close, emaPeriod) : true
isEmaDowntrend = useEmaFilter ? close < ta.ema(close, emaPeriod) : true
useSmaFilter = input.bool(title="使用SMA过滤器", defval=false, group="过滤器", inline="sma")
smaPeriod = input.int(title="周期", defval=200, minval=1, step=1, group="过滤器", inline="sma", tooltip="用于SMA过滤器的SMA的周期.")
isSmaUptrend = useSmaFilter ? close > ta.sma(close, smaPeriod) : true
isSmaDowntrend = useSmaFilter ? close < ta.sma(close, smaPeriod) : true

// Nadaraya-Watson 核回归设置
useKernelFilter = input.bool(true, "使用核回归", group="核设置", inline="kernel")
showKernelEstimate = input.bool(true, "显示核估计", group="Kernel Settings", inline="kernel")
useKernelSmoothing = input.bool(false, "增强核平滑", tooltip="使用基于交叉的机制来平滑核颜色变化。这通常会导致整体颜色转换较少，并可能导致生成更多的ML入场信号.", inline='1', group='核设置')
h = input.int(8, '回溯窗口', minval=3, tooltip='用于估计的柱数量。这是一个滑动值，表示最近的历史柱。建议范围：3-50', group="核设置", inline="kernel")
r = input.float(8., '相对加权', step=0.25, tooltip='时间框架的相对加权。当这个值接近零时，较长时间框架对估计的影响将更大。当这个值接近无穷大时，有理二次核的行为将与高斯核相同。建议范围：0.25-25', group="核设置", inline="kernel")
x = input.int(25, "回归水平", tooltip='开始回归的柱索引。控制核估计与数据的拟合程度。较小的值是较紧密的拟合。较大的值是较松散的拟合。建议范围：2-25', group="核设置", inline="kernel")
lag = input.int(2, "滞后", tooltip="交叉检测的滞后。较低的值会导致较早的交叉。建议范围：1-2", inline='1', group='Kernel Settings')

// 显示设置
showBarColors = input.bool(true, "显示柱颜色", tooltip="是否显示柱颜色.", group="显示设置")
showBarPredictions = input.bool(defval = true, title = "显示柱预测数值", tooltip = "将显示ML模型对每个柱的评估值（整数）.", group="显示设置")
useAtrOffset = input.bool(defval = false, title = "使用ATR偏移", tooltip = "将使用ATR偏移而不是柱预测偏移.", group="显示设置")
barPredictionsOffset = input.float(0, "柱预测偏移", minval=0, tooltip="柱预测相对于柱高或收盘的百分比偏移.", group="显示设置")

// =================================
// ==== Next Bar Classification ====
// =================================

// 该模型专门用于预测接下来的4根柱的价格走势方向。
// 为了避免与ML模型的复杂性，这个值被硬编码为4根柱，但将来可能会添加对其他训练长度的支持。
src = settings.source
y_train_series = src[4] < src[0] ? direction.short : src[4] > src[0] ? direction.long : direction.neutral
var y_train_array = array.new_int(0)

// Variables used for ML Logic
var predictions = array.new_float(0)
var prediction = 0.
var signal = direction.neutral
var distances = array.new_float(0)

array.push(y_train_array, y_train_series)

// =========================
// ====  Core ML Logic  ====
// =========================

// 利用洛伦兹距离进行近似最近邻搜索：
// 这是最近邻（NN）搜索算法的一种新颖变体，确保邻居在时间上均匀分布。

// 在传统的基于KNN的方法中，我们会遍历整个数据集，计算当前柱与数据集中的每个其他柱之间的距离，然后按升序对距离进行排序。
// 然后，我们会选择前k个柱，并使用它们的标签来确定当前柱的标签。

// 在实时计算涉及时间序列数据的情况下，传统的KNN方法存在以下几个问题：
// - 遍历整个数据集并计算每个历史柱与当前柱之间的距离是计算上昂贵的。
// - 市场时间序列数据通常是非平稳的，意味着数据的统计特性会随时间略微变化。
// - 最近邻可能不是最具信息性的，如果最近邻不代表大多数数据，KNN算法可能会返回较差的结果。

// 以前，用户@capissimo尝试通过几个基于PineScript的KNN实现来解决其中一些问题，方法包括：
// - 使用基于连续最远邻的修改KNN算法来找到一组近似的“最近”邻居。
// - 使用滑动窗口方法，只计算当前柱与数据集中最近的n个柱之间的距离。

// 在这两种方法中，后一种方法受制于只考虑整体数据集中最近的柱的事实。

// 前一种方法更有潜力利用历史价格走势，但受以下限制：
// - 突然的“max”值可能会干扰估计
// - 选择一组近似邻居可能不代表大多数数据，因为它们在时间上的差异不够明显
// - 选择太多“远”邻居可能会导致对价格走势的估计不准确

// 为了解决这些问题，本指标使用了一种新颖的近似最近邻（ANN）算法。

// 在下面的ANN算法中：
// 1. 该算法按照时间顺序遍历数据集，使用模运算符仅在每4根柱上执行计算。
// 这既减少了算法的计算开销，又确保了邻居之间的最小时间间隔至少为4根柱。
// 2. 同时在预测数组和相应的距离数组中维护一组k个相似的邻居。
// 3. 当预测数组的大小超过settings.neighborsCount中指定的所需最近邻的数量时，
// 该算法会从预测数组和相应的距离数组中移除第一个邻居。
// 4. lastDistance变量被覆盖为数组中低25%位置的距离。这一步有助于通过确保后续新添加的距离值以较慢的速度增加来提高总体准确性。
// 5. 洛伦兹距离作为距离度量用于最小化异常值的影响，并考虑到“价格时间”由于接近重大经济事件而发生的弯曲。

lastDistance = -1.0
size = math.min(settings.maxBarsBack-1, array.size(y_train_array)-1)
sizeLoop = math.min(settings.maxBarsBack-1, size)

if bar_index >= maxBarsBackIndex //{
    for i = 0 to sizeLoop //{
        d = get_lorentzian_distance(i, settings.featureCount, featureSeries, featureArrays)
        if d >= lastDistance and i%4 //{
            lastDistance := d
            array.push(distances, d)
            array.push(predictions, math.round(array.get(y_train_array, i)))
            if array.size(predictions) > settings.neighborsCount //{
                lastDistance := array.get(distances, math.round(settings.neighborsCount*3/4))
                array.shift(distances)
                array.shift(predictions)
            //}
        //}
    //}
    prediction := array.sum(predictions)
//}

// ============================
// ==== Prediction Filters ====
// ============================

// 用户定义的过滤器：用于调整ML模型预测的频率。
filter_all = filter.volatility and filter.regime and filter.adx

// 过滤信号：在应用用户定义的过滤器后，模型对未来价格走势方向的预测。
signal := prediction > 0 and filter_all ? direction.long : prediction < 0 and filter_all ? direction.short : nz(signal[1])

// 柱计数过滤器：代表基于预定义的持有期（4根柱）的严格过滤器。
var int barsHeld = 0
barsHeld := ta.change(signal) ? 0 : barsHeld + 1
isHeldFourBars = barsHeld == 4
isHeldLessThanFourBars = 0 < barsHeld and barsHeld < 4

// 分形过滤器：从给定时间序列分形/片段中信号的相对出现衍生而来，具有默认长度为4根柱。
isDifferentSignalType = ta.change(signal)
isEarlySignalFlip = ta.change(signal) and (ta.change(signal[1]) or ta.change(signal[2]) or ta.change(signal[3]))
isBuySignal = signal == direction.long and isEmaUptrend and isSmaUptrend
isSellSignal = signal == direction.short and isEmaDowntrend and isSmaDowntrend
isLastSignalBuy = signal[4] == direction.long and isEmaUptrend[4] and isSmaUptrend[4]
isLastSignalSell = signal[4] == direction.short and isEmaDowntrend[4] and isSmaDowntrend[4]
isNewBuySignal = isBuySignal and isDifferentSignalType
isNewSellSignal = isSellSignal and isDifferentSignalType

// 核回归过滤器：基于Nadaraya-Watson核回归，使用有理二次核进行过滤
// 有关这一技术的更多信息，请参考我在以下位置的其他开源指标：
// https://www.tradingview.com/script/AWNvbPRM-Nadaraya-Watson-Rational-Quadratic-Kernel-Non-Repainting/
c_green = color.new(#009988, 20)
c_red = color.new(#CC3311, 20)
transparent = color.new(#000000, 100)
yhat1 = kernels.rationalQuadratic(settings.source, h, r, x)
yhat2 = kernels.gaussian(settings.source, h-lag, x)
kernelEstimate = yhat1
// Kernel Rates of Change
bool wasBearishRate = yhat1[2] > yhat1[1]
bool wasBullishRate = yhat1[2] < yhat1[1]
bool isBearishRate = yhat1[1] > yhat1
bool isBullishRate = yhat1[1] < yhat1
isBearishChange = isBearishRate and wasBullishRate
isBullishChange = isBullishRate and wasBearishRate
// Kernel Crossovers
bool isBullishCrossAlert = ta.crossover(yhat2, yhat1)
bool isBearishCrossAlert = ta.crossunder(yhat2, yhat1)
bool isBullishSmooth = yhat2 >= yhat1
bool isBearishSmooth = yhat2 <= yhat1
// Kernel Colors
color colorByCross = isBullishSmooth ? c_green : c_red
color colorByRate = isBullishRate ? c_green : c_red
color plotColor = showKernelEstimate ? (useKernelSmoothing ? colorByCross : colorByRate) : transparent
plot(kernelEstimate, color=plotColor, linewidth=2, title="Kernel Regression Estimate")
// Alert Variables
bool alertBullish = useKernelSmoothing ? isBullishCrossAlert : isBullishChange
bool alertBearish = useKernelSmoothing ? isBearishCrossAlert : isBearishChange
// Bullish and Bearish Filters based on Kernel
isBullish = useKernelFilter ? (useKernelSmoothing ? isBullishSmooth : isBullishRate) : true
isBearish = useKernelFilter ? (useKernelSmoothing ? isBearishSmooth : isBearishRate) : true

// ===========================
// ==== Entries and Exits ====
// ===========================

// 入场条件：用于ML模型持仓入场的布尔值。
startLongTrade = isNewBuySignal and isBullish and isEmaUptrend and isSmaUptrend
startShortTrade = isNewSellSignal and isBearish and isEmaDowntrend and isSmaDowntrend

// 动态出场条件：基于分形过滤器和核回归过滤器的ML模型持仓出场的布尔值。
lastSignalWasBullish = ta.barssince(startLongTrade) < ta.barssince(startShortTrade)
lastSignalWasBearish = ta.barssince(startShortTrade) < ta.barssince(startLongTrade)
barsSinceRedEntry = ta.barssince(startShortTrade)
barsSinceRedExit = ta.barssince(alertBullish)
barsSinceGreenEntry = ta.barssince(startLongTrade)
barsSinceGreenExit = ta.barssince(alertBearish)
isValidShortExit = barsSinceRedExit > barsSinceRedEntry
isValidLongExit = barsSinceGreenExit > barsSinceGreenEntry
endLongTradeDynamic = (isBearishChange and isValidLongExit[1])
endShortTradeDynamic = (isBullishChange and isValidShortExit[1])

// 固定出场条件：基于柱计数过滤器的ML模型持仓出场的布尔值。
endLongTradeStrict = ((isHeldFourBars and isLastSignalBuy) or (isHeldLessThanFourBars and isNewSellSignal and isLastSignalBuy)) and startLongTrade[4]
endShortTradeStrict = ((isHeldFourBars and isLastSignalSell) or (isHeldLessThanFourBars and isNewBuySignal and isLastSignalSell)) and startShortTrade[4]
isDynamicExitValid = not useEmaFilter and not useSmaFilter and not useKernelSmoothing
endLongTrade = settings.useDynamicExits and isDynamicExitValid ? endLongTradeDynamic : endLongTradeStrict
endShortTrade = settings.useDynamicExits and isDynamicExitValid ? endShortTradeDynamic : endShortTradeStrict

// =========================
// ==== Plotting Labels ====
// =========================

// 注意：这些图形在最近的柱完全关闭后不会重绘。默认情况下，信号出现在最后一个关闭的柱上；要覆盖此行为，请将offset=0设置为0。
// plotshape(startLongTrade ? low : na, 'Buy', shape.labelup, location.belowbar, color=ml.color_green(prediction), size=size.small, offset=0)
// plotshape(startShortTrade ? high : na, 'Sell', shape.labeldown, location.abovebar, ml.color_red(-prediction), size=size.small, offset=0)
// plotshape(endLongTrade and settings.showExits ? high : na, 'StopBuy', shape.xcross, location.absolute, color=#3AFF17, size=size.tiny, offset=0)
// plotshape(endShortTrade and settings.showExits ? low : na, 'StopSell', shape.xcross, location.absolute, color=#FD1707, size=size.tiny, offset=0)

// ================
// ==== Alerts ====
// ================

// 入场和出场分开的警报。
// alertcondition(startLongTrade, title='Open Long ▲', message='LDC Open Long ▲ | {{ticker}}@{{close}} | ({{interval}})')
// alertcondition(endLongTrade, title='Close Long ▲', message='LDC Close Long ▲ | {{ticker}}@{{close}} | ({{interval}})')
// alertcondition(startShortTrade, title='Open Short ▼', message='LDC Open Short  | {{ticker}}@{{close}} | ({{interval}})')
// alertcondition(endShortTrade, title='Close Short ▼', message='LDC Close Short ▼ | {{ticker}}@{{close}} | ({{interval}})')

// 入场和出场的合并警报。
// alertcondition(startShortTrade or startLongTrade, title='Open Position ▲▼', message='LDC Open Position ▲▼ | {{ticker}}@{{close}} | ({{interval}})')
// alertcondition(endShortTrade or endLongTrade, title='Close Position ▲▼', message='LDC Close Position  ▲▼ | {{ticker}}@[{{close}}] | ({{interval}})')

// 核估计警报。
// alertcondition(condition=alertBullish, title='Kernel Bullish Color Change', message='LDC Kernel Bullish ▲ | {{ticker}}@{{close}} | ({{interval}})')
// alertcondition(condition=alertBearish, title='Kernel Bearish Color Change', message='LDC Kernel Bearish ▼ | {{ticker}}@{{close}} | ({{interval}})')

// =========================
// ==== Display Signals ====
// =========================

// atrSpaced = useAtrOffset ? ta.atr(1) : na
// compressionFactor = settings.neighborsCount / settings.colorCompression
// c_pred = prediction > 0 ? color.from_gradient(prediction, 0, compressionFactor, #787b86, #009988) : prediction <= 0 ? color.from_gradient(prediction, -compressionFactor, 0, #CC3311, #787b86) : na
// c_label = showBarPredictions ? c_pred : na
// c_bars = showBarColors ? color.new(c_pred, 50) : na
// x_val = bar_index
// y_val = useAtrOffset ? prediction > 0 ? high + atrSpaced: low - atrSpaced : prediction > 0 ? high + hl2*barPredictionsOffset/20 : low - hl2*barPredictionsOffset/30
// label.new(x_val, y_val, str.tostring(prediction), xloc.bar_index, yloc.price, color.new(color.white, 100), label.style_label_up, c_label, size.normal, text.align_left)
// barcolor(showBarColors ? color.new(c_pred, 50) : na)